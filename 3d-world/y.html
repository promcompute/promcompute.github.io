<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sci-Fi 3D World</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: #000;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            background: rgba(0, 20, 40, 0.8);
            padding: 20px;
            border: 2px solid #00ff00;
            border-radius: 5px;
            font-size: 14px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        
        #controls h2 {
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff00;
        }
        
        #controls p {
            margin: 5px 0;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #00ffff;
            background: rgba(0, 20, 40, 0.8);
            padding: 15px;
            border: 2px solid #00ffff;
            border-radius: 5px;
            font-size: 12px;
        }
        
        .button {
            background: #003366;
            border: 1px solid #00ff00;
            color: #00ff00;
            padding: 8px 15px;
            margin: 5px;
            cursor: pointer;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s;
        }
        
        .button:hover {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 15px #00ff00;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <h2>‚ö° CONTROL PANEL ‚ö°</h2>
        <p>üéÆ <strong>WASD</strong> - Move Around</p>
        <p>üñ±Ô∏è <strong>Mouse Drag</strong> - Look Around</p>
        <p>‚¨ÜÔ∏è <strong>Space</strong> - Move Up</p>
        <p>‚¨áÔ∏è <strong>Shift</strong> - Move Down</p>
        <p>üéØ <strong>Click</strong> - Interact</p>
        <div style="margin-top: 15px;">
            <button class="button" onclick="toggleAnimation()">Toggle Rotation</button>
            <button class="button" onclick="changeView()">Change View</button>
        </div>
    </div>
    
    <div id="info">
        <div>Position: <span id="pos">0, 0, 0</span></div>
        <div>Objects: <span id="objects">0</span></div>
        <div>FPS: <span id="fps">60</span></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000510, 0.002);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 20);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
        scene.add(ambientLight);
        
        const mainLight = new THREE.PointLight(0x00ffff, 1.5, 100);
        mainLight.position.set(0, 20, 0);
        mainLight.castShadow = true;
        scene.add(mainLight);
        
        const light2 = new THREE.PointLight(0xff00ff, 1, 50);
        light2.position.set(-20, 10, -20);
        scene.add(light2);
        
        const light3 = new THREE.PointLight(0x00ff00, 1, 50);
        light3.position.set(20, 10, 20);
        scene.add(light3);
        
        // Starfield
        function createStarfield() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            for (let i = 0; i < 3000; i++) {
                vertices.push(
                    Math.random() * 600 - 300,
                    Math.random() * 600 - 300,
                    Math.random() * 600 - 300
                );
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.3 });
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }
        createStarfield();
        
        // Central Space Station
        function createSpaceStation() {
            const group = new THREE.Group();
            
            // Main hub
            const hubGeometry = new THREE.SphereGeometry(3, 32, 32);
            const hubMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a4d6d,
                emissive: 0x0088cc,
                emissiveIntensity: 0.2,
                shininess: 100
            });
            const hub = new THREE.Mesh(hubGeometry, hubMaterial);
            hub.castShadow = true;
            group.add(hub);
            
            // Rotating rings
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.TorusGeometry(5 + i * 2, 0.3, 16, 100);
                const ringMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.5
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                ring.rotation.y = i * 0.5;
                ring.userData.rotationSpeed = 0.001 * (i + 1);
                group.add(ring);
            }
            
            // Solar panels
            for (let i = 0; i < 4; i++) {
                const panelGeometry = new THREE.BoxGeometry(0.1, 4, 2);
                const panelMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x0066cc,
                    emissive: 0x0033ff,
                    emissiveIntensity: 0.3
                });
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                const angle = (Math.PI * 2 / 4) * i;
                panel.position.set(Math.cos(angle) * 8, 0, Math.sin(angle) * 8);
                panel.rotation.y = angle;
                group.add(panel);
            }
            
            group.position.set(0, 10, 0);
            return group;
        }
        const spaceStation = createSpaceStation();
        scene.add(spaceStation);
        
        // Floating platforms
        function createPlatform(x, y, z, color) {
            const geometry = new THREE.CylinderGeometry(4, 4, 0.5, 6);
            const material = new THREE.MeshPhongMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.2,
                flatShading: true
            });
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, y, z);
            platform.castShadow = true;
            platform.receiveShadow = true;
            
            // Add energy core
            const coreGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.position.y = 1;
            platform.add(core);
            core.userData.pulseSpeed = Math.random() * 0.02 + 0.01;
            
            return platform;
        }
        
        const platforms = [];
        platforms.push(createPlatform(-15, 2, -15, 0x9933ff));
        platforms.push(createPlatform(15, 3, -15, 0xff3366));
        platforms.push(createPlatform(-15, 2.5, 15, 0x33ff99));
        platforms.push(createPlatform(15, 3.5, 15, 0xffcc00));
        platforms.forEach(p => scene.add(p));
        
        // Asteroids
        function createAsteroid(x, y, z, size) {
            const geometry = new THREE.DodecahedronGeometry(size, 0);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x666666,
                flatShading: true
            });
            const asteroid = new THREE.Mesh(geometry, material);
            asteroid.position.set(x, y, z);
            asteroid.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
            asteroid.userData.rotationSpeed = {
                x: Math.random() * 0.01 - 0.005,
                y: Math.random() * 0.01 - 0.005,
                z: Math.random() * 0.01 - 0.005
            };
            asteroid.castShadow = true;
            return asteroid;
        }
        
        const asteroids = [];
        for (let i = 0; i < 20; i++) {
            const asteroid = createAsteroid(
                Math.random() * 80 - 40,
                Math.random() * 30 + 5,
                Math.random() * 80 - 40,
                Math.random() * 1.5 + 0.5
            );
            asteroids.push(asteroid);
            scene.add(asteroid);
        }
        
        // Holographic pillars
        function createHoloPillar(x, z) {
            const geometry = new THREE.CylinderGeometry(0.3, 0.3, 8, 6);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.4,
                wireframe: true
            });
            const pillar = new THREE.Mesh(geometry, material);
            pillar.position.set(x, 4, z);
            return pillar;
        }
        
        const pillars = [];
        for (let i = 0; i < 8; i++) {
            const angle = (Math.PI * 2 / 8) * i;
            const pillar = createHoloPillar(Math.cos(angle) * 25, Math.sin(angle) * 25);
            pillars.push(pillar);
            scene.add(pillar);
        }
        
        // Ground grid
        const gridHelper = new THREE.GridHelper(100, 50, 0x00ffff, 0x003333);
        gridHelper.position.y = 0;
        scene.add(gridHelper);
        
        // Controls
        const keys = {};
        const mouse = { x: 0, y: 0, isDragging: false, lastX: 0, lastY: 0 };
        let cameraRotation = { x: 0, y: 0 };
        
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        
        document.addEventListener('mousedown', (e) => {
            mouse.isDragging = true;
            mouse.lastX = e.clientX;
            mouse.lastY = e.clientY;
        });
        
        document.addEventListener('mouseup', () => mouse.isDragging = false);
        
        document.addEventListener('mousemove', (e) => {
            if (mouse.isDragging) {
                const deltaX = e.clientX - mouse.lastX;
                const deltaY = e.clientY - mouse.lastY;
                
                cameraRotation.y -= deltaX * 0.002;
                cameraRotation.x -= deltaY * 0.002;
                cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
                
                mouse.lastX = e.clientX;
                mouse.lastY = e.clientY;
            }
        });
        
        // Animation controls
        let animationEnabled = true;
        let viewMode = 0;
        
        window.toggleAnimation = () => {
            animationEnabled = !animationEnabled;
        };
        
        window.changeView = () => {
            viewMode = (viewMode + 1) % 3;
            if (viewMode === 1) {
                camera.position.set(0, 50, 0);
                camera.lookAt(0, 0, 0);
            } else if (viewMode === 2) {
                camera.position.set(40, 20, 40);
                camera.lookAt(0, 10, 0);
            }
        };
        
        // Animation loop
        let lastTime = Date.now();
        let frames = 0;
        let lastFpsUpdate = Date.now();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = Date.now();
            const delta = currentTime - lastTime;
            lastTime = currentTime;
            
            // FPS counter
            frames++;
            if (currentTime - lastFpsUpdate > 1000) {
                document.getElementById('fps').textContent = frames;
                frames = 0;
                lastFpsUpdate = currentTime;
            }
            
            // Camera movement (only in mode 0)
            if (viewMode === 0) {
                const speed = 0.2;
                const direction = new THREE.Vector3();
                
                if (keys['w']) {
                    direction.z -= Math.cos(cameraRotation.y) * speed;
                    direction.x -= Math.sin(cameraRotation.y) * speed;
                }
                if (keys['s']) {
                    direction.z += Math.cos(cameraRotation.y) * speed;
                    direction.x += Math.sin(cameraRotation.y) * speed;
                }
                if (keys['a']) {
                    direction.x -= Math.cos(cameraRotation.y) * speed;
                    direction.z += Math.sin(cameraRotation.y) * speed;
                }
                if (keys['d']) {
                    direction.x += Math.cos(cameraRotation.y) * speed;
                    direction.z -= Math.sin(cameraRotation.y) * speed;
                }
                if (keys[' ']) direction.y += speed;
                if (keys['shift']) direction.y -= speed;
                
                camera.position.add(direction);
                
                // Update camera rotation
                camera.rotation.order = 'YXZ';
                camera.rotation.y = cameraRotation.y;
                camera.rotation.x = cameraRotation.x;
            }
            
            // Animate objects
            if (animationEnabled) {
                // Rotate space station rings
                spaceStation.children.forEach(child => {
                    if (child.userData.rotationSpeed) {
                        child.rotation.z += child.userData.rotationSpeed;
                    }
                });
                
                // Rotate asteroids
                asteroids.forEach(asteroid => {
                    asteroid.rotation.x += asteroid.userData.rotationSpeed.x;
                    asteroid.rotation.y += asteroid.userData.rotationSpeed.y;
                    asteroid.rotation.z += asteroid.userData.rotationSpeed.z;
                });
                
                // Pulse platform cores
                platforms.forEach(platform => {
                    const core = platform.children[0];
                    if (core) {
                        const pulse = Math.sin(Date.now() * core.userData.pulseSpeed) * 0.3 + 1;
                        core.scale.set(pulse, pulse, pulse);
                    }
                });
                
                // Animate pillars
                pillars.forEach((pillar, i) => {
                    pillar.position.y = 4 + Math.sin(Date.now() * 0.001 + i) * 0.5;
                });
                
                // Rotate lights
                const time = Date.now() * 0.001;
                light2.position.x = Math.cos(time) * 20;
                light2.position.z = Math.sin(time) * 20;
                light3.position.x = Math.cos(time + Math.PI) * 20;
                light3.position.z = Math.sin(time + Math.PI) * 20;
            }
            
            // Update info
            document.getElementById('pos').textContent = 
                `${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)}`;
            document.getElementById('objects').textContent = scene.children.length;
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        animate();
    </script>
</body>
</html>